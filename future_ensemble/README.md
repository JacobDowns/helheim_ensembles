# Purpose
This folder contains code for running an ensemble of runs simulating Helheim from 2007-2050 using a previously generated posterior distribution of model parameters. This code uses `gnu-paralle` to run several simulations at once. 

```
sudo apt-get install parallel
```
# Running 

The script `run_all.sh` will run all simulations in parallel. By default this will run 10 simulations at once. This script causes `do_run.sh i` where `i` is the index run, which will in turn invoke the `do_run.m` script. Output for the i-th run will be written to folder `results/i`. Model progress / error messages can be found in `results/i/output.txt`. When a run finishes the results will be written in `results/i/results_i.mat`.

# Code Breakdown

Here's a quick breakdon of the model code. On each run we first load an array containing states generated by the Markov model that control the calving stress threshold. We also load an array with parameter values for each run. 

```
addpath /home/jake/trunk-jpl/bin/ /home/jake/trunk-jpl/lib/
markov_sequences = load('data/future_markov_sequences.mat');
posterior = load('data/posterior.mat').posterior;
posterior = transpose(posterior);
```

This just extracts individual parameter values for the i-th run. 

```
% Frontal melt rate 
p0 = posterior(1,:);
% Minimum melt rate param
p1 = posterior(2,:);
% Ice temperature offset
p2 = posterior(3,:);
% Calving stress
p3 = posterior(4,:);
% Min calving stress ratio
p4 = posterior(5,:);

p0 = p0(i)
p1 = p1(i)
p2 = p2(i)
p3 = p3(i)
p4 = p4(i)
```

There are different model files with different basal traction fields corresponding to different temperatrues. This code just loads the correct model file depending on the temperature offset parameter.

```
j = round(p2 + 10) + 1;
load(strcat('data/models/model_', int2str(j), '.mat'));
```

Get the sequence of states for the i-th model run. The array `ts` contains the starting time of each Markov state. 

```
ts = markov_sequences.ts;
sequence = markov_sequences.markov_sequences(i,:);
```

THe future runoff input is generated by repeating runoff from 2007-2019 repeatedly. Runoff values are normalized due the the parameterizaztion of marine melt. 

```
% Surface runoff extended into the future by extending runoff
surface_runoff = load('data/surface_runoff_extended.mat').surface_runoff;
runoff_ts = surface_runoff.ts;
qs = surface_runoff.surface_runoff;
% Normalize runoff
qs = qs / max(qs);
```

Change to the results directory for the i-th run. Set parameterizations. Don't know that much about these, but they're what Mathieu used. Set run and timestepping parameters. 

```

cd(strcat('results/', int2str(i)));

md.groundingline.migration = 'SubelementMigration';
md.groundingline.friction_interpolation = 'SubelementFriction2';
md.groundingline.melt_interpolation = 'SubelementMelt2';

md.timestepping.time_step = 0.005;
md.timestepping.start_time = 2007;
md.timestepping.final_time = 2050;
md.settings.output_frequency = 10;
```

Set time series of submarine melt, parameterized interms of `m_max` and `m_min`. In ISSM this takes the form a huge

```
m_max = p0;
m_min = p0*p1;
qs = zeros(md.mesh.numberofvertices + 1, size(runoff_ts,2)) + qs;
md.frontalforcings.meltingrate = (sqrt((m_max-m_min)^2 * qs) + m_min);
md.frontalforcings.meltingrate(end,:) = runoff_ts;
```
