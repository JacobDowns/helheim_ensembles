# Purpose
This folder contains code for running an ensemble of runs simulating Helheim from 2007-2050 using a previously generated posterior distribution of model parameters. This code uses `gnu-paralle` to run several simulations at once. 

```
sudo apt-get install parallel
```
# Running 

The script `run_all.sh` will run all simulations in parallel. By default this will run 10 simulations at once. This script causes `do_run.sh i` where `i` is the index run, which will in turn invoke the `do_run.m` script. Output for the i-th run will be written to folder `results/i`. Model progress / error messages can be found in `results/i/output.txt`. When a run finishes the results will be written in `results/i/results_i.mat`.

# Code Breakdown

Here's a quick breakdon of the model code. On each run we first load an array containing states generated by the Markov model that control the calving stress threshold. We also load an array with parameter values for each run. 

```
addpath /home/jake/trunk-jpl/bin/ /home/jake/trunk-jpl/lib/
markov_sequences = load('data/future_markov_sequences.mat');
posterior = load('data/posterior.mat').posterior;
posterior = transpose(posterior);
```

This just extracts individual parameter values for the i-th run. 

```
% Frontal melt rate 
p0 = posterior(1,:);
% Minimum melt rate param
p1 = posterior(2,:);
% Ice temperature offset
p2 = posterior(3,:);
% Calving stress
p3 = posterior(4,:);
% Min calving stress ratio
p4 = posterior(5,:);

p0 = p0(i)
p1 = p1(i)
p2 = p2(i)
p3 = p3(i)
p4 = p4(i)
```

There are different model files with different basal traction fields corresponding to different temperatrues. This code just loads the correct model file depending on the temperature offset parameter.

```
j = round(p2 + 10) + 1;
load(strcat('data/models/model_', int2str(j), '.mat'));
```

Get the sequence of states for the i-th model run. The array `ts` contains the starting time of each Markov state. 

```
ts = markov_sequences.ts;
sequence = markov_sequences.markov_sequences(i,:);
```

THe future runoff input is generated by repeating runoff from 2007-2019 repeatedly. Runoff values are normalized due the the parameterizaztion of marine melt. 

```
% Surface runoff extended into the future by extending runoff
surface_runoff = load('data/surface_runoff_extended.mat').surface_runoff;
runoff_ts = surface_runoff.ts;
qs = surface_runoff.surface_runoff;
% Normalize runoff
qs = qs / max(qs);
```

Change to the results directory for the i-th run. Set parameterizations. Don't know that much about these, but they're what Mathieu used. Set run and timestepping parameters. 

```

cd(strcat('results/', int2str(i)));

md.groundingline.migration = 'SubelementMigration';
md.groundingline.friction_interpolation = 'SubelementFriction2';
md.groundingline.melt_interpolation = 'SubelementMelt2';

md.timestepping.time_step = 0.005;
md.timestepping.start_time = 2007;
md.timestepping.final_time = 2050;
md.settings.output_frequency = 10;
```

Set time series of submarine melt, parameterized interms of `m_max` and `m_min`. In ISSM this takes the form a huge $N+1 \times K$ array where $N$ is the number of nodes in the FEM mesh and $K$ is the number time steps at which the runoff is defined. The last row in the array contains the times at which runoff is defined. ISSM will interpolate runoff between given time steps. In this case there is no spatial variation in melt rate, so every mesh node is set to the same value. 

```
m_max = p0;
m_min = p0*p1;
qs = zeros(md.mesh.numberofvertices + 1, size(runoff_ts,2)) + qs;
md.frontalforcings.meltingrate = (sqrt((m_max-m_min)^2 * qs) + m_min);
md.frontalforcings.meltingrate(end,:) = runoff_ts;
```

Set the ice temperatue based on the ice temperatue offset. Once temperature is adjusted the ice rheology is changed to reflect that temperature. The initial ice rheology with the baseline temperature is saved for future reference. 

```
% Ice temperature
B0 = paterson(md.initialization.temperature);
md.initialization.temperature = min(md.initialization.temperature + p2, 273.15);
B1 = paterson(md.initialization.temperature);
md.materials.rheology_B = B1; 
```

Next, we define a spatially and temporally varying stress threshold parameter field. The von Mises calving law is given by 

$$
c = ||v|| \frac{ \sqrt{3} B \tilde{\epsilon_e}^{1/n}}{\sigma_{max}}
$$

which depends on the ice softness $B$ that depends on the temperature offset used in the model. To negate the direct impact of ice temperature on calving, we multiply the ice calving stress threshold parameter by a factor that divides out the ice rheology term and mulitplies by a standardized value corresponding to 0C. 

```
sigma_max = p3 * (paterson(273.15) ./ B0);
```

There are two calving stress threshold terms for floating and grounded ice. We set both of these to the same values. 
```
sigma_min = sigma_max*p4;
sigma_max(end+1) = 0;
sigma_min(end+1) = 0;
indicator = zeros(md.mesh.numberofvertices + 1, size(ts,2)) + sequence;
size(indicator)
md.calving.stress_threshold_floatingice = indicator.*(sigma_max - sigma_min) + sigma_min;
size(md.calving.stress_threshold_floatingice)
md.calving.stress_threshold_floatingice(end,:) = ts;
md.calving.stress_threshold_groundedice = md.calving.stress_threshold_floatingice;
```

The remainder of the code is simply the code to run the model. 

```
% Solve
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

md.miscellaneous.name = ['param_', num2str(i)];
md.transient.isthermal = 0;
md.transient.requested_outputs={'default', 'IceVolume', 'CalvingCalvingrate', 'IceVolumeAboveFloatation','IceVolumeAboveFloatationScaled','GroundedArea','FloatingArea','GroundedAreaScaled','FloatingAreaScaled','IceMass'};

md.cluster=generic('name',oshostname, 'np', 3);
md=solve(md,'Transient','runtimename',false);
save(strcat('results_',  int2str(i), '.mat'), 'md', '-v7.3')
```
